import ReactDOM from "react-dom/client";
import { createPortal } from "react-dom";
import { useEffect, useState } from "react";
import { SummarizeButton } from "./summarize-button";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ThemeProvider } from "../ui/theme/theme-provider";
import { YouTubeServiceSafe as YouTubeService, YouTubeThumbnailElement, YouTubeNavigationEvent } from "./services/youtube-service-safe";
import { extractVideoInfo, hasExistingButton, removeExistingButtons, markAsProcessed, isProcessed, getButtonPosition } from "./utils/youtube-dom-utils";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
      refetchOnWindowFocus: false,
    },
  },
});

// Initialize YouTube service with safe, non-intrusive settings
const youtubeService = new YouTubeService({
  debug: true,
  debounceMs: 500, // Less aggressive
  processingDelay: 1000, // Wait for YouTube to load content
});

interface ProcessedThumbnail extends YouTubeThumbnailElement {
  videoInfo: {
    videoId: string;
    title: string;
    channel: string;
    url: string;
  };
  id: string;
}

const ButtonContainer = () => {
  const [thumbnails, setThumbnails] = useState<ProcessedThumbnail[]>([]);

  useEffect(() => {
    console.log('[ButtonContainer] Initializing...');

    // Handle navigation events
    const unsubscribeNavigation = youtubeService.onNavigation((event: YouTubeNavigationEvent) => {
      console.log('[ButtonContainer] Navigation event:', event);
      
      if (event.type === 'finish') {
        // Clear thumbnails on navigation finish to force re-detection
        setThumbnails([]);
      }
    });

    // Handle thumbnail detection
    const unsubscribeThumbnails = youtubeService.onThumbnailsDetected((detectedThumbnails: YouTubeThumbnailElement[]) => {
      console.log('[ButtonContainer] Thumbnails detected:', detectedThumbnails.length);
      
      const processedThumbnails: ProcessedThumbnail[] = [];

      detectedThumbnails.forEach((thumbnail, index) => {
        // Skip if already processed
        if (isProcessed(thumbnail.element)) {
          return;
        }

        // Skip if already has a button
        if (hasExistingButton(thumbnail.element)) {
          return;
        }

        const videoInfo = extractVideoInfo(thumbnail.element, thumbnail.type);
        if (!videoInfo || !videoInfo.videoId) {
          console.log('[ButtonContainer] Skipping thumbnail - no video info:', thumbnail);
          return;
        }

        // Remove any existing buttons first
        removeExistingButtons(thumbnail.element);

        // Mark as processed
        markAsProcessed(thumbnail.element);

        processedThumbnails.push({
          ...thumbnail,
          videoInfo,
          id: `${thumbnail.type}-${videoInfo.videoId}-${index}`,
        });
      });

      if (processedThumbnails.length > 0) {
        console.log('[ButtonContainer] Adding processed thumbnails:', processedThumbnails.length);
        setThumbnails(prev => [...prev, ...processedThumbnails]);
      }
    });

    // Initialize the YouTube service
    youtubeService.initialize();

    // Cleanup
    return () => {
      console.log('[ButtonContainer] Cleaning up...');
      unsubscribeNavigation();
      unsubscribeThumbnails();
      youtubeService.destroy();
    };
  }, []);

  console.log('[ButtonContainer] Rendering with thumbnails:', thumbnails.length);

  return (
    <>
      {thumbnails.map((thumbnail) => (
        <SummarizeButtonPortal
          key={thumbnail.id}
          thumbnailElement={thumbnail.element}
          videoId={thumbnail.videoInfo.videoId}
          title={thumbnail.videoInfo.title}
          channel={thumbnail.videoInfo.channel}
          type={thumbnail.type}
        />
      ))}
    </>
  );
};

// Portal component to inject buttons into thumbnail elements
const SummarizeButtonPortal = ({
  thumbnailElement,
  videoId,
  title,
  channel,
  type,
}: {
  thumbnailElement: HTMLElement;
  videoId: string;
  title: string;
  channel: string;
  type: "regular" | "end-card" | "metadata" | "player" | "shorts" | "live" | "premiere";
}) => {
  const [container] = useState(() => document.createElement("div"));

  useEffect(() => {
    // Apply positioning styles based on thumbnail type
    const buttonStyles = getButtonPosition(type);
    Object.assign(container.style, buttonStyles);

    container.classList.add("yt-summarize-container");
    thumbnailElement.appendChild(container);

    console.log('[SummarizeButtonPortal] Button injected for:', { videoId, title, type });

    return () => {
      try {
        if (container.parentNode) {
          container.parentNode.removeChild(container);
        }
      } catch (error) {
        console.error('[SummarizeButtonPortal] Error removing container:', error);
      }
    };
  }, [container, thumbnailElement, type]);

  const handleWrapperClick = (e: React.MouseEvent) => {
    if (type === "end-card") {
      e.stopPropagation();
      e.preventDefault();
    }
  };

  return createPortal(
    <div
      onClick={handleWrapperClick}
      onMouseDown={handleWrapperClick}
      onMouseUp={handleWrapperClick}
    >
      <SummarizeButton
        videoId={videoId}
        title={title}
        channel={channel}
        type={type}
      />
    </div>,
    container
  );
};

export const InitNew = () => {
  useEffect(() => {
    console.log('[InitNew] Starting YouTube Summarize Extension...');
    
    // Create a single root container for our app
    const rootContainer = document.createElement("div");
    rootContainer.id = "yt-summarize-root";
    document.body.appendChild(rootContainer);

    const root = ReactDOM.createRoot(rootContainer);
    root.render(
      <ThemeProvider>
        <QueryClientProvider client={queryClient}>
          <ButtonContainer />
        </QueryClientProvider>
      </ThemeProvider>
    );

    console.log('[InitNew] Extension initialized successfully');

    return () => {
      console.log('[InitNew] Cleaning up extension...');
      root.unmount();
      if (rootContainer.parentNode) {
        rootContainer.parentNode.removeChild(rootContainer);
      }
    };
  }, []);

  return null;
};
